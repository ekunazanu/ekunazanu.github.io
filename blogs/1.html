<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Fourier Transforms</title>
	<link rel="icon" href="../resources/icons/67.16px.svg">
	<link rel="stylesheet" href="../resources/main.style.css">
</head>

<body>
    <header>
        <a href="https://plan67.dev/">
        <svg viewBox="0 0 5 5">
        <path id="rect6" d="M 0 0 L 0 5 L 3 5 L 3 2 L 1 2 L 1 0 z M 1 3 L 2 3 L 2 4 L 1 4 L 1 3 z" />
        <path id="rect7" d="M 2 0 L 2 1 L 4 1 L 4 5 L 5 5 L 5 0 L 2 0 z" />
        </svg>
       	</a>
        <time>2023-02-12</time>
        <h1>Fourier Transforms</h1>
    </header>

<main>
<article>
<p>Welcome back to my blog, it’s been a while. Over the past few months I’ve been busier with other aspects of my life than expected, hence the lack of status updates. Despite that, I’ve made progress on various fronts.</p>

<h2>Waylock 0.4.0 and Rewrite</h2>
<p>Yesterday I finally released <a href="https://github.com/ifreund/waylock/releases/tag/v0.4.0">waylock 0.4.0</a> which has been rewritten in <a href="https://ziglang.org/">Zig</a>. It now uses the <a href="https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131">ext-session-lock-v1</a> protocol, which I worked on earlier this year and discussed in my <a href="https://isaacfreund.com/blog/2022-02/">February 2022</a> update. Unfortunately, <a href="https://github.com/riverwm/river">river</a> itself does not yet support this protocol. The work is already done and there’s been a <a href="https://github.com/riverwm/river/pull/497">pull request</a>  implementing it open for quite some time, the only thing I’m waiting on is a wlroots release including the session lock implementation. I intend to spend some more time working on upstream wlroots to help tie up various loose ends before 0.16.0 and further develop the scene graph API.</p>

<figure>
<picture>
<source srcset="https://cdn.pixabay.com/photo/2021/12/29/08/18/insect-6900940_960_720.jpg" media="(prefers-color-scheme: dark)" alt="fire">
<img src="https://www.gstatic.com/webp/gallery/4.webp" alt="mountains" loading="lazy" decoding="async">
</picture>
<figcaption>Mountains over here something something something</figcaption>
</figure>

<h3>Rewrite</h3>
<p>Rewriting waylock from Rust into Zig has made me think once again about the different trade-offs made by the two languages and their ecosystems. Looking at the Rust code I wrote several years ago I am rather appalled by how many dependencies it has. If I’ve managed to use the cargo tooling correctly, I count 48 crates that waylock 0.3.5 depends on in addition to linking the system libxkbcommon and PAM libraries. That is a <em>lot</em> of code running inside my application that I never read let alone seriously audited.</p>
<p>The only real answer I have to this question is that the Rust version and its dependencies do a lot of abstraction,
and that abstractions are seldom “zero cost” in practice despite what people may tell you.</p>

<h2>Improvements</h2>
<p>Rewriting waylock in Zig also led me to rexamine some aspects of <a href="https://github.com/ifreund/zig-wayland">zig-wayland</a>, particularly regarding its usage in client applications. The scanner (which generates zig bindings from xml protocol specifications) now requires the user to explicitly request:
</p>

<pre><code>#!/usr/bin/env python3

while i < len(sorted_M) and not all(l >= S for l in slot):
    if slot[j % R] + sorted_M[i][0] <= S:
        sorted_M[i].append(j % R)
        sorted_M[i].append(slot[j % R])
        slot[j % R] += sorted_M[i][0]
        if i % R == (R - 1): j += 1
        j += 1
    else:
        for k in range(R):
            if slot[k % R] + sorted_M[i][0] <= S:
                sorted_M[i].append(k % R)
                sorted_M[i].append(slot[k % R])
                slot[k % R] += sorted_M[i][0]
                break
    i += 1
print(sorted_M)
print(slot)
</code></pre>
The application must now call <code>sortedArray</code> to complete the process job.</p>

<h2>Performance Gains</h2>

<figure>
<div style="overflow: auto;">
<table>
        <tr>
            <th>Partitions</th>
        	<th>Windows Readable Partition</th>
        	<th colspan="2">LUKS Container</th>
        	<th>BIOS Grub Partition</th>
        	<th>UEFI Boot Partition</th>
        </tr>
        <tr>
            <th>gdisk hex</th>
        	<td>0700</td>
        	<td colspan="2">8300</td>
        	<td>ef02</td>
    	<td>ef00</td>
        </tr>
        <tr>
            <th rowspan="2">Block Device</th>
        	<td>/dev/sdx1</td>
        	<td colspan="2">/dev/sdx2</td>
        	<td>/dev/sdx3</td>
            <td>/dev/sdx4</td>
        </tr> 
        <tr>
    	<td></td>
        <td>/dev/VolumeGroup/root</td>
        	<td>/dev/VolumeGroup/home</td>
            <td colspan="2"></td>
        </tr>  
        <tr>
            <th rowspan="2">Size</th>
        	<td rowspan="2">As required</td>
    	    <td>At least 8GiB</td>
        	<td>As required</td>
    	    <td rowspan="2">2MiB</td>
        	<td rowspan="2">200MiB</td>
        </tr>
        <tr>
            <td colspan="2">(LUKS Container must accomodate size of both Logical volumes)</td>
        </tr>
        <tr>
            <th>File System</th>
        	<td>FAT32/NTFS</td>
        	<td>ext4</td>
        	<td>ext4</td>
        	<td>Unformatted</td>
        	<td>FAT32</td>
        </tr> 
        <tr>
            <th>Mountpoint</th>
        	<td>Not Mounted</td>
        	<td>/</td>
        	<td>/home</td>
        	<td>Not Mounted</td>
        	<td>/boot</td>
        </tr>
</table>
</div>
<figcaption>The newer algorithm performs significantly better</figcaption>
</figure>

<h2>River Progress</h2>
<p>River has also gained some nice new features recently:</p>
<ul>
    <li>Automatic cursor hiding after a timeout or when typing was contributed by Duncan Overbruck.</li>
    <li>On moving the cursor after it has been hidden it will be shown again.</li>
    <li>Initial support for the idle-inhibit protocol was contributed by dfangx.</li>
    <li>No longer shall swayidle put your monitor to sleep while watching a movie in mpv!</li>
    <li>Mapping of lid and tablet switches was contributed by Peter Kaplan.</li>
    <li>Now you can have a command run when you close the lid of your laptop!</li>
    <li>Peter Kaplan also contributed a very nice feature for people switching between multiple keyboard layouts: layout independent mappings.</li>
    <li>The riverctl map command has gained a -layout option taking an index into the list of layouts set with XKB_DEFAULT_LAYOUT. If passed, keyboard input will always be interpreted using the given layout, ignoring the currently active xkb layout.</li>
</ul>

<p>Note that these features are not yet available in a released version of river, only on the git master branch. I plan to release river 0.2.0 shortly after wlroots 0.16.0 is released.</p>
<p>Thanks for reading and till next time!</p>

</article>
</main>

<footer>
    &copy; 2023-<script>document.write(new Date().getFullYear())</script> Anchit Roy &middot;
    <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener noreferrer">CC BY-SA 4.0</a>
</footer>
</body>
</html>

<!-- Published under the MIT License -->
<!-- https://opensource.org/licenses/MIT -->